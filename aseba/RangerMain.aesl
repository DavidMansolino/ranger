<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="15" name="mainFeedback"/>
<event size="19" name="mainFeedbackWithEncoders"/>
<event size="3" name="setLed"/>
<event size="10" name="receiverFeedback"/>
<event size="2" name="setSpeed"/>
<event size="1" name="enableEncoders"/>
<event size="2" name="playLedVid"/>
<event size="0" name="stopLedVid"/>
<event size="5" name="neuilFeedback"/>
<event size="8" name="neuilEvent"/>
<event size="10" name="customEvent"/>
<event size="7" name="emitterEvent"/>
<event size="1" name="enableFeedback"/>


<!--list of constants-->
<constant value="600" name="CURRENT_LIMIT"/>
<constant value="60" name="POS_REACHED_STEPS"/>
<constant value="23" name="EYES_PWM_CONSTANT"/>
<constant value="13" name="NB_TIMER0_CYCLES"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node RangerMain-->
<node nodeId="1" name="RangerMain">var touchLeftThreshold[9] = [154, 144, 132, 138, 120, 133, 155, 111, 117]
var touchRightThreshold[9] = [239, 219, 195, 196, 181, 208, 219, 166, 176]
var touchRearThreshold[9] = [147, 140, 132, 135, 116, 138, 155, 129, 129]
var touchBuffer[2]
var i
var j
var timer = 0
var encoderEnabled = 0
var playingVid = 0
var repeatVid = 0
var TouchRight
var TouchLeft
var TouchRear
var TmpBumber = 0
var mainFeedbackEnable = 0

mot1.pid.current_max = 3500
mot2.pid.current_max = 3500

# switch off all leds
for i in 0:185 do
	call led.set(i, 0, 0, 0)
end

# touch panel calibration
for i in 0:8 do
	if i > 4 then # because 5 and 6 are not for touch panel
		j = 163 + i + 2 
	else
		j = 163 + i
	end
	# right
	touchBuffer[0] = j
	touchBuffer[1] = touchRightThreshold[i]&lt;&lt;2 | 1
	call touch.debug(0, touchBuffer, 0)
	# rear
	touchBuffer[0] = j
	touchBuffer[1] = touchRearThreshold[i]&lt;&lt;2 | 1
	call touch.debug(1, touchBuffer, 0)
	# left
	touchBuffer[0] = j
	touchBuffer[1] = touchLeftThreshold[i]&lt;&lt;2 | 1
	call touch.debug(2, touchBuffer, 0)
end
touch._disable = 0

# stop motors
mot1.pid.enable = 2
mot1.pid.target_current = 0
mot1.pid.target_speed = 0
mot2.pid.enable = 2
mot2.pid.target_current = 0
mot2.pid.target_speed = 0

onevent setLed
for i in 0:185 do
  call led.set(i, event.args[0], event.args[1], event.args[2])
end

# Simulate bumber with the motor current
sub computeTmpBumber
if mot1.pid.target_current > CURRENT_LIMIT or mot1.pid.target_current &lt; -CURRENT_LIMIT or mot2.pid.target_current > CURRENT_LIMIT or mot2.pid.target_current &lt; -CURRENT_LIMIT then
	TmpBumber = 1
else
	TmpBumber = 0
end

# Compress touchSensors in order to use only one variable by pannel
sub touchCompress
TouchRight = 0
TouchLeft = 0
TouchRear = 0
j = 1
for i in 0:8 do
	TouchRight += touch.right[i]*j
	TouchLeft  += touch.left[i]*j
	TouchRear  += touch.rear[i]*j
	j *= 2
end


#event acc used to send data
onevent acc
if mainFeedbackEnable != 0 then
	callsub touchCompress
	callsub computeTmpBumber
	if encoderEnabled == 1 then
		emit mainFeedbackWithEncoders[acc, sharp, vbat, TmpBumber, mot1.speed, mot2.speed, TouchRight, TouchLeft, TouchRear, mot1.enc._pulse, mot2.enc._pulse, _status.ExtPower, mot1._raw_current, -mot2._raw_current]
	else
		emit mainFeedback[acc, sharp, vbat, TmpBumber, mot1.speed, mot2.speed, TouchRight, TouchLeft, TouchRear, _status.ExtPower, mot1._raw_current, -mot2._raw_current]
	end
end
if _status.ExtPower == 1 then
	call led.vid.stop()
end


onevent setSpeed
mot1.pid.enable = 2
mot1.pid.target_speed = event.args[0]
mot2.pid.enable = 2
mot2.pid.target_speed = event.args[1]

onevent enableEncoders
encoderEnabled = event.args[0]

onevent playLedVid
repeatVid = 0
call led.vid.stop()
playingVid = event.args[0]
repeatVid = event.args[1]
call led.vid.start(playingVid)

onevent led # Video is finished
if repeatVid == 1 then
	call led.vid.start(playingVid)
else
	call led.vid.stop()
end

onevent stopLedVid
call led.vid.stop()
repeatVid = 0

onevent enableFeedback
mainFeedbackEnable = event.args[0]
</node>


<!--node rab2-->
<node nodeId="7" name="rab2">var rabFeedbackEnable = 0
var c
rf.id = 7
rf.swarm_size = 25
rf.slot_time = 4000
rx.power.en = 1
tx.power.en = 1
call rf.start()


onevent packet.rx
if rabFeedbackEnable != 0 then
	emit receiverFeedback[rx.source, rx.angle, rx.dist, rx.data]
end


onevent emitterEvent
for c in 0:6 do
	rf.tx_data[c] = event.args[c]
end

onevent enableFeedback
rabFeedbackEnable = event.args[0]</node>


<!--node neuil-->
<node nodeId="15" name="neuil">var mainFeedbackEnable = 0
var i
var j
# PWM order: leftVlPupil leftHpupil leftUeyelid leftLeyelid rightLeyelid rightUeyelid rightHpupil rightVpupil
var pos_min[8]    = [   0,    0,  800,  900,  800,  800,    0,    0]
var pos_center[8] = [ 850, 1000, 1000, 1000, 1000, 1000,  900, 1000]
var pos_max[8]    = [1000, 1000, 1200, 1300, 1200, 1200, 1000, 1000]
var pos_target[8]
var pos_actual[8]
var posReached[8]
var angle[4] = [0, 0, 0, 0]
var X = 0
var Y = 0
var open_oeil_in_X_timer0_cycles

pos_target = pos_center
call math.fill(pos_actual, 0)

timer[0] = 10
timer[1] = 100
sharp.enable[0] = 1
sharp.enable[1] = 1
sharp.enable[2] = 1

pos_target[2]=pos_min[2]
pos_target[3]=pos_max[3]
pos_target[4]=pos_min[4]
pos_target[5]=pos_max[5]

## this is an example of use of the custom event in order to do a wink
sub call_Ouvert
pos_target[2]=pos_min[2]
pos_target[3]=pos_max[3]
pos_target[4]=pos_min[4]
pos_target[5]=pos_max[5]

sub call_Ferme
pos_target[2]=pos_max[2]
pos_target[3]=pos_min[3]
pos_target[4]=pos_max[4]
pos_target[5]=pos_min[5]

sub call_Haut
pos_target[0]=1122
pos_target[1]=975
pos_target[6]=909
pos_target[7]=784

sub call_Bas
pos_target[0]=642
pos_target[1]=975
pos_target[6]=909
pos_target[7]=1264

sub call_Gauche
pos_target[0]=872
pos_target[1]=730
pos_target[6]=686
pos_target[7]=1014

sub call_Droite
pos_target[0]=872
pos_target[1]=1245
pos_target[6]=1165
pos_target[7]=1014

onevent customEvent
if event.args[0] == 1 then #clin d'oeil
	callsub call_Ferme
	open_oeil_in_X_timer0_cycles =  NB_TIMER0_CYCLES
	if event.args[1] == 1 then
		callsub call_Gauche
	elseif event.args[1] == 2 then
		callsub call_Droite
	end
end

onevent timer0
if open_oeil_in_X_timer0_cycles > 0 then  # manage the wink
	open_oeil_in_X_timer0_cycles--
	if  open_oeil_in_X_timer0_cycles == 0 then
		callsub call_Ouvert
	end
end
for i in 0:7 do
	if pos_actual[i] == 0 then
		pos_actual[i] = pos_target[i]
		servo.pwm[i] = pos_target[i]
	elseif pos_target[i] == pos_actual[i] then	
		if posReached[i] != 1 then	
			if posReached[i] == 0 then # servo is at the correct location since 'POS_REACHED_STEPS' steps, we can switch it off by setting the PWM to 0
				posReached[i] = 1
				servo.pwm[i] = 0
			else
				posReached[i]++
			end
		end
	else
		pos_actual[i] = pos_target[i]
		servo.pwm[i] = pos_actual[i]
		posReached[i] = -POS_REACHED_STEPS
	end
end

# feedback 
onevent timer1
if mainFeedbackEnable != 0 then
	emit neuilFeedback [sharp.value, lolette, balance]
end

### Command received ###
onevent neuilEvent
### Make sure consign is between -100 and 100
for i in 0:7 do
	if event.args[i] > 100 then
		event.args[i] = 100
	elseif event.args[i] &lt; -100 then
		event.args[i] = -100
	end
end

###  EyeLids
pos_target[2] = ((100-event.args[4]) * ((pos_max[2] - pos_min[2])/10)) / 10 + pos_min[2]

pos_target[3] = (event.args[5] * ((pos_max[3] - pos_min[3])/10)) / 10 + pos_min[3]

pos_target[4] = ((100-event.args[6]) * ((pos_max[4] - pos_min[4])/10)) / 10 + pos_min[4]

pos_target[5] = (event.args[7] * ((pos_max[5] - pos_min[5])/10)) / 10 + pos_min[5]

### Eyes
## make sure that consign is in the circle of radius 100 center in {0,0}
# Left eye
j = event.args[0] * event.args[0] + event.args[1] * event.args[1]
call math.sqrt(j, j)
if j > 100 then # out of circle of radius 100
	event.args[0] = (event.args[0] * 100) / j
	event.args[1] = (event.args[1] * 100) / j
end

# Right eye
j = event.args[2] * event.args[2] + event.args[3] * event.args[3]
call math.sqrt(j, j)
if j > 100 then # out of circle of radius 100
	event.args[2] = (event.args[2] * 100) / j
	event.args[3] = (event.args[3] * 100) / j
end

## Compute and apply target position of each motor
#motor 0
Y = (26 * event.args[1])
X = 5000 + (26 * event.args[0]) # 26 instead of 52.85/2 
call math.atan2(angle[0], Y, X)
pos_target[0] = pos_center[0] + angle[0] / EYES_PWM_CONSTANT
#motor 1 
Y = (26 * event.args[0])
X = 5000 - (26 * event.args[1]) # 26 instead of 52.85/2 
call math.atan2(angle[1], Y, X)
pos_target[1] = pos_center[1] + angle[1] / EYES_PWM_CONSTANT
#motor 7
Y = -(26 * event.args[3])
X = 5000 + (26 * event.args[2]) # 26 instead of 52.85/2 
call math.atan2(angle[2], Y, X)
pos_target[7] = pos_center[7] + angle[2] / EYES_PWM_CONSTANT
#motor 6
Y = -(26 * event.args[2])
X = 5000 - (26 * event.args[3]) # 26 instead of 52.85/2 
call math.atan2(angle[3], Y, X)
pos_target[6] = pos_center[6] + angle[3] / EYES_PWM_CONSTANT


onevent enableFeedback
mainFeedbackEnable = event.args[0]
</node>


</network>
